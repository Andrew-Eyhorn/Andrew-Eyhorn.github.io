<html>

<head>
    <style>
        .numberSet {
            display: inline-block
        }

        .number {
            background-color:paleturquoise;
            margin: 3px;
            width: 10%;
            height: 20px;
        }

        .observing {
            background-color: rgb(255, 123, 0);
        }
        .minValue {
            background-color: #f44336;
        }
    </style>
</head>

<body>
    <div id='numberSet'></div>
    <label for="delay">Delay(seconds):</label> <select id="delay">
        <option value = 0>0</option>
        <option value = 0.1>0.1</option>
        <option value = 0.2>0.2</option>
        <option value = 0.3>0.3</option>
        <option value = 0.4>0.4</option>
        <option selected value = 0.5>0.5</option>
        <option value = 0.6>0.6</option>
        <option value = 0.7>0.7</option>
        <option value = 0.8>0.8</option>
        <option value = 0.9>0.9</option>
        <option value = 1>1</option>
    </select>
    <label>Algorithm:</label> <select id="algorithmOption">
        <option value="bubbleSort">Bubble Sort</option>
        <option value="selectionSort">Selection Sort</option>
    </select>
    <button id="goButton" onclick="runAlgorithm()">Go</button>
</body>
<script>
    const sleep = (milliseconds) => {
        return new Promise(resolve => setTimeout(resolve, milliseconds))
    }
    const numberOfElements = 10;
    let numberSet = [];
    let swapPlaceHolder = 0;
    let numberSetPlaceholder;
    let delay = 0;

    function generateNumbers() {
        for (i = 0; i < numberOfElements; i++) {
            let randomNumber = Math.round((Math.random() * ((19 - 1) + 1)) + 1);
            numberSet.push(randomNumber);
        };
        //numberSet = [11,19,12,18,8,2,18,2,8,16];
    }

    function generateStyles() {
        for (i = 0; i < 20; i++) {
            document.styleSheets[0].addRule(`[data-value = "${i}"]`, `width: ${i * 10}px`)
        };
    }

    function displayNumbers() {
        for (let number of numberSet) {
            let numberSetVisual = document.createElement('div');
            numberSetVisual.classList.add('number');
            numberSetVisual.setAttribute('data-value', number);
            numberSetVisual.appendChild(document.createTextNode(number));
            numberSetPlaceholder.appendChild(numberSetVisual);
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        numberSetPlaceholder = document.getElementById('numberSet')
        generateStyles();
        generateNumbers();
        displayNumbers();
    });

    function runAlgorithm() {
        delay = document.getElementById("delay").value * 1000;
        let algorithmType = document.getElementById('algorithmOption').selectedOptions[0].value;
        if (algorithmType === 'bubbleSort') {
            bubbleSort();
            console.log(numberSet);
        } else if (algorithmType === 'selectionSort') {
            selectionSort();
            console.log(numberSet);
        }
    }
    console.log(numberSet);

    var numbersSwapped = true;
    async function passthrough() {
        numbersSwapped = false
        for (i = 0; i < numberOfElements - 1; i++) {
            numberSetPlaceholder.children[i].classList.add('observing');
            numberSetPlaceholder.children[i + 1].classList.add('observing');
            await sleep(delay);
            if (numberSet[i] <= numberSet[i + 1]) {
                numberSetPlaceholder.children[i].classList.remove('observing');
                numberSetPlaceholder.children[i + 1].classList.remove('observing');
                continue;
            }
            numberSetPlaceholder.children[i].classList.remove('observing');
            numberSetPlaceholder.children[i + 1].classList.remove('observing');
            await swapElements(i, i+1);
            numbersSwapped = true;

        }



    }
    async function swapElements(index1, index2) {
        let distance = index2 - index1;
        let rowHeight = numberSetPlaceholder.children[index1].clientHeight;
        let swapDistance = distance * (rowHeight + 3);
        numberSetPlaceholder.children[index2].setAttribute('style', `transform: translate(0px, -${swapDistance}px); background-color: aqua; transition: background-color ${delay}ms, transform ${delay}ms`);
        numberSetPlaceholder.children[index1].setAttribute('style', `transform: translate(0px, ${swapDistance}px); background-color: aqua; transition: background-color ${delay}ms, transform ${delay}ms`);
        await sleep(delay);
        swapPlaceHolder = numberSet[index2];
        numberSet[index2] = numberSet[index1];
        numberSet[index1] = swapPlaceHolder;
        numberSetPlaceholder.children[index2].removeAttribute('style')
        numberSetPlaceholder.children[index1].removeAttribute('style')
        if (distance === 1) {
            numberSetPlaceholder.children[index2].after(numberSetPlaceholder.children[index1]);
        } else {
            numberSetPlaceholder.children[index1].after(numberSetPlaceholder.children[index2]);
            numberSetPlaceholder.children[index2].after(numberSetPlaceholder.children[index1]);
        }
    }

    async function bubbleSort() {
        while (numbersSwapped) {
            await passthrough();
        }
    }
    async function selectionSort() {
        var numbersSorted = 0
        for (i = 0; i < numberOfElements - 1; i++) {
            var currentMin = numberSet[i];
            var minValueIndex = i
            for (j = numbersSorted + 1; j < numberOfElements; j++) {
                numberSetPlaceholder.children[minValueIndex].classList.add('minValue')
                numberSetPlaceholder.children[j].classList.add('observing')
                await sleep(delay); 
                if (numberSet[j] < currentMin) {
                    numberSetPlaceholder.children[j].classList.remove('observing');
                    numberSetPlaceholder.children[minValueIndex].classList.remove('minValue');
                    currentMin = numberSet[j]
                    minValueIndex = j
                } else {
                    numberSetPlaceholder.children[j].classList.remove('observing');
                }

            }
            numberSetPlaceholder.children[i].classList.add('observing')
            await sleep(delay); 
            numberSetPlaceholder.children[minValueIndex].classList.remove('minValue');
            numberSetPlaceholder.children[i].classList.remove('observing');
            if (numberSet[i] !== currentMin) {
                numberSetPlaceholder.children[minValueIndex].classList.remove('minValue');
                await swapElements(i, minValueIndex)
            }
            numbersSorted += 1;
        }
        console.log(numberSet);
    }
    console.log(numberSet);
</script>

</html>